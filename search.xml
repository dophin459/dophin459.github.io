<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[RLP编码原理]]></title>
      <url>%2Fposts%2F98130c96%2F</url>
      <content type="text"><![CDATA[RLP(Recursive Length Prefix，递归长度前缀)是一种编码算法，用于编码任意的嵌套结构的二进制数据，它是以太坊中数据序列化/反序列化的主要方法，区块、交易等数据结构在持久化时会先经过RLP编码后再存储到数据库中。 定义RLP编码的定义只处理两类数据：一类是字符串（例如字节数组），一类是列表。字符串指的是一串二进制数据，列表是一个嵌套递归的结构，里面可以包含字符串和列表，例如[&quot;cat&quot;,[&quot;puppy&quot;,&quot;cow&quot;],&quot;horse&quot;,[[]],&quot;pig&quot;,[&quot;&quot;],&quot;sheep&quot;]就是一个复杂的列表。其他类型的数据需要转成以上的两类，转换的规则不是RLP编码定义的，可以根据自己的规则转换，例如struct可以转成列表，int可以转成二进制（属于字符串一类），以太坊中整数都以大端形式存储。 RLP编码规则 对于单个字节，如果它的值范围是[0x00, 0x7f]，它的RLP编码就是它本身。 否则，如果一个字符串的长度是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着字符串本身，这个前缀的值是0x80加上字符串的长度。由于被编码的字符串最大长度是55=0x37,因此单字节前缀的最大值是0x80+0x37=0xb7，即编码的第一个字节的取值范围是[0x80, 0xb7]。 如果字符串的长度大于55个字节，它的RLP编码包含一个单字节的前缀，后面跟着字符串的长度，后面再跟着字符串本身。这个前缀的值是0xb7加上字符串长度的二进制形式的字节长度，说的有点绕，举个例子就明白了，例如一个字符串的长度是1024，它的二进制形式是10000000000，这个二进制形式的长度是2个字节，所以前缀应该是0xb7+2=0xb9，字符串长度1024=0x400，因此整个RLP编码应该是\xb9\x04\x00再跟上字符串本身。编码的第一个字节即前缀的取值范围是[0xb8, 0xbf]，因为字符串长度二进制形式最少是1个字节，因此最小值是0xb7+1=0xb8，字符串长度二进制最大是8个字节，因此最大值是0xb7+8=0xbf。 如果一个列表的总长度（列表的总长度指的是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着列表中各元素项的RLP编码，这个前缀的值是0xc0加上列表的总长度。编码的第一个字节的取值范围是[0xc0, 0xf7]。 如果一个列表的总长度大于55字节，它的RLP编码包含一个单字节的前缀，后面跟着列表的长度，后面再跟着列表中各元素项的RLP编码，这个前缀的值是0xf7加上列表总长度的二进制形式的字节长度。编码的第一个字节的取值范围是[0xf8, 0xff]。 RLP编码例子 字符串 &quot;dog&quot; = [0x83, &#39;d&#39;, &#39;o&#39;, &#39;g&#39; ] （规则二） 列表 [&quot;cat&quot;,&quot;dog&quot;] = [0xc8, 0x83, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, 0x83, &#39;d&#39;, &#39;o&#39;, &#39;g&#39; ] （规则四） 空字符串 &quot;&quot; = 0x80 （规则二） 空列表 [] = [0xc0] （规则四） 整数 15(&#39;\x0f&#39;) = 0x0f （规则一） 整数 1024(&#39;\x04\00&#39;) = [0x82, 0x04, 0x00] （规则二） 列表 [ [], [[]], [ [], [[]] ] ] = [0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0] （规则四） 字符串 &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot; = [0xb8, 0x38, &#39;L&#39;, &#39;o&#39;, &#39;r&#39;, &#39;e&#39;, &#39;m&#39;, &#39; &#39;, ... , &#39;e&#39;, &#39;l&#39;, &#39;i&#39;, &#39;t&#39;] （规则三）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Linux上安装docker和docker-compose]]></title>
      <url>%2Fposts%2F62ef6528%2F</url>
      <content type="text"><![CDATA[安装docker在终端中执行以下命令安装： $ curl -sSL https://get.daocloud.io/docker | sh 出现以下内容，说明安装成功了： Client: Version: 17.04.0-ce API version: 1.28 Go version: go1.7.5 Git commit: 4845c56 Built: Mon Apr 3 18:07:42 2017 OS/Arch: linux/amd64Server: Version: 17.04.0-ce API version: 1.28 (minimum version 1.12) Go version: go1.7.5 Git commit: 4845c56 Built: Mon Apr 3 18:07:42 2017 OS/Arch: linux/amd64 Experimental: falseIf you would like to use Docker as a non-root user, you should now consideradding your user to the &quot;docker&quot; group with something like: sudo usermod -aG docker zhangdaofengRemember that you will have to log out and back in for this to take effect! 确认docker是否成功安装了：$ sudo docker run hello-world 反馈如下，则安装成功。Unable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world78445dd45222: Pull complete Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 安装docker-compose Docker Compose是一个用来定义和运行复杂应用的Docker工具。使用Compose，你可以在一个文件中定义一个多容器应用，然后使用一条命令来启动你的应用，完成一切准备工作。 一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose，不再需要使用shell脚本来启动容器。在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动、停止和重启应用，以及应用中的服务以及所有依赖服务的容器。 运行下面的命令来安装 Compose：curl -L https://github.com/docker/compose/releases/download/1.12.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 注意：如果你在安装的时候出现了 “Permission denied” 的错误信息，这说明你的 /usr/local/bin 目录是不可写的，你需要使用超级用户来安装。运行 sudo -i , 然后运行上边的两个命令，然后 exit 退出。 也可以使用pip安装：$ sudo pip install -U docker-compose 到这里安装就结束了；Compose已经安装完成。你可以使用 docker-compose --version 来进行测试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[go-ethereum源码剖析：交易]]></title>
      <url>%2Fposts%2Fd1cec06d%2F</url>
      <content type="text"><![CDATA[交易是区块链中最基本也是最核心的一个概念，在以太坊中，交易更是重中之重，因为以太坊是一个智能合约平台，以太坊上的应用都是通过智能合约与区块链进行交互，而智能合约的执行是由交易触发的，没有交易，智能合约就是一段死的代码，可以说在以太坊中，一切都源于交易。下面就来看看在以太坊中交易是什么样的，交易里面都有什么。 交易的数据结构在core/types/transaction.go中定义了交易的数据结构：type Transaction struct &#123; data txdata // caches hash atomic.Value size atomic.Value from atomic.Value&#125; 在这个结构体里面只有一个data字段，它是txdata类型的，其他的三个字段hash size from是缓存字段，txdata也是一个结构体，它里面定义了交易的具体的字段：type txdata struct &#123; AccountNonce uint64 Price, GasLimit *big.Int Recipient *common.Address `rlp:"nil"` // nil means contract creation Amount *big.Int Payload []byte V *big.Int // signature R, S *big.Int // signature&#125; 各字段的含义如下： AccountNonce：此交易的发送者已发送过的交易数 Price：此交易的gas price GasLimit：本交易允许消耗的最大gas数量 Recipient：交易的接收者，是一个地址 Amount：交易转移的以太币数量，单位是wei Payload：交易可以携带的数据，在不同类型的交易中有不同的含义 V R S：交易的签名数据 注意：这里并没有一个字段来指明交易的发送者，因为交易的发送者地址可以从签名中得到。 交易的类型在源码中交易只有一种数据结构，如果非要给交易分个类的话，我认为交易可以分为三种：转账的交易、创建合约的交易、执行合约的交易。web3.js提供了发送交易的接口：web3.eth.sendTransaction(transactionObject [, callback]) 参数是一个对象，在发送交易的时候指定不同的字段，区块链节点就可以识别出对应类型的交易。 转账的交易转账是最简单的一种交易，这里转账是指从一个账户向另一个账户发送以太币。发送转账交易的时候只需要指定交易的发送者、接收者、转币的数量。使用web3.js发送转账交易应该像这样：web3.eth.sendTransaction(&#123; from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", to: "0xd46e8dd67c5d32be8058bb8eb970870f07244567", value: 10000000000000000&#125;); value是转移的以太币数量，单位是wei，对应的是源码中的Amount字段。to对应的是源码中的Recipient。 创建合约的交易创建合约指的是将合约部署到区块链上，这也是通过发送交易来实现。在创建合约的交易中，to字段要留空不填，在data字段中指定合约的二进制代码，from字段是交易的发送者也是合约的创建者。web3.eth.sendTransaction(&#123; from: "contract creator's address", data: "contract binary code"&#125;); data字段对应的是源码中的Payload字段。 执行合约的交易调用合约中的方法，需要将交易的to字段指定为要调用的合约的地址，通过data字段指定要调用的方法以及向该方法传递的参数。web3.eth.sendTransaction(&#123; from: "sender's address", to: "contract address", data: "hash of the invoked method signature and encoded parameters"&#125;); data字段需要特殊的编码规则，具体细节可以参考Ethereum Contract ABI。自己拼接字段既不方便又容易出错，所以一般都使用封装好的SDK来调用合约。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[go-ethereum源码阅读环境搭建]]></title>
      <url>%2Fposts%2F2d535e99%2F</url>
      <content type="text"><![CDATA[接触以太坊有几个月了，这期间陆陆续续读了一些源码，阅读源码对深入理解以太坊和区块链的原理是非常有用的，通过阅读源码可以知道交易、区块等核心数据结构的组成，可以对区块链的底层实现原理和运行过程有一个更清晰的认识，很多不明确的问题都可以从源码中找到答案。 网上以太坊的技术资料挺多的，但多数是关于智能合约和应用开发的，真正涉及底层实现和源码的很少。所以我想把自己阅读源码的学习心得总结记录下来，一是方便自己查阅，也可以给别人参考。 本文介绍以太坊go-ethereum源码的阅读环境配置。以太坊有8种语言的实现，选择go-ethereum是因为它是以太坊的官方实现版本，包含了以太坊的所有特性，比较权威和全面，它是用go语言编写的，go语言学习起来比较容易，而且可读性也比较好。 阅读源码有一个代码编辑器就够了，但是为了更好的体验和更高的效率，还需要做一些配置，比如代码高亮、代码跳转等。 安装go语言为了能支持代码跳转，需要安装go语言，安装教程参考这篇文章，其中最重要的是要保证正确设置了GOPATH，这样才能进行代码跳转。如果想学习go语言，可以看一下在线教程A Tour of Go，或者去看《The Go Programming Language》这本书。 配置编辑器看代码可以选择你喜欢的代码编辑器，我用的是Visual Studio Code，为了支持go语言代码高亮，需要安装一个插件。在vscode的插件面板中搜索lukehoban，安装即可。 接下来安装一些go语言工具，在命令行中执行以下命令安装：go get -u -v github.com/nsf/gocodego get -u -v github.com/rogpeppe/godefgo get -u -v github.com/zmb3/gogetdocgo get -u -v github.com/golang/lint/golintgo get -u -v github.com/lukehoban/go-outlinego get -u -v sourcegraph.com/sqs/goreturnsgo get -u -v golang.org/x/tools/cmd/gorenamego get -u -v github.com/tpng/gopkgsgo get -u -v github.com/acroca/go-symbolsgo get -u -v golang.org/x/tools/cmd/gurugo get -u -v github.com/cweill/gotests/...go get -u -v golang.org/x/tools/cmd/godocgo get -u -v github.com/fatih/gomodifytags 下载源码以太坊代码都托管在github上，它的代码经常更新，每次更新会加入一些新的东西，也可能改变代码的组织架构，所以最好选择一个稳定版阅读，目前最新的稳定版本是1.5.9，到这里下载源码后，解压到GOPATH/src/github.com/ethereum/go-ethereum中，解压后目录结构应该是这样的：GOPATH/src├── github.com └── ethereum └── go-ethereum 路径和目录名一定要与上面的一致，不能放到其他地方或者改成其他名字，因为go语言是按照路径搜索包的。 其实上面最重要的就是要正确设置了GOPATH，并且要把源码放到GOPATH/src中正确的路径中。接下来就可以开始阅读代码了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以太坊开发实战：通过truffle-contract与智能合约交互]]></title>
      <url>%2Fposts%2F79b3ba3d%2F</url>
      <content type="text"><![CDATA[与以太坊的智能合约交互，除了使用web3.js，还可以使用另外一个Javascript库，就是truffle-contract。truffle-contract对以太坊的智能合约做了更好的抽象，相比于web3.js，使用truffle-contract操作智能合约更加方便。 truffle-contract具有以下特色： 同步的交易：可以确保在交易生效之后再继续执行其他操作 返回Promise：每个封装的合约函数会返回Promise，可以对它进行.then操作，避免了回调地狱（callback hell）问题 为交易提供了默认参数：例如from或gas 为每个同步的交易返回logs、交易receipt和交易hash 下面介绍如何在应用中使用truffle-contract与智能合约交互。 系统和软件 Ubuntu 16.04 64位 nodejs 6.10.0 npm 3.10.10 示例合约还是以上一篇文章中的MetaCoin合约为例，确保启动了一个以太坊节点，并且已将下面的MetaCoin合约部署到节点中。// 本文中用到的MetaCoin合约pragma solidity ^0.4.2;contract MetaCoin &#123; mapping (address =&gt; uint) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function MetaCoin() &#123; balances[tx.origin] = 10000; &#125; function sendCoin(address receiver, uint amount) returns(bool sufficient) &#123; if (balances[msg.sender] &lt; amount) return false; balances[msg.sender] -= amount; balances[receiver] += amount; Transfer(msg.sender, receiver, amount); return true; &#125; function getBalance(address addr) returns(uint) &#123; return balances[addr]; &#125;&#125; 接下来就可以按照下面的步骤在项目中通过truffle-contract来使用这个合约。 安装truffle-contract首先新建一个Nodejs项目并初始化：$ mkdir truffle-contract-test &amp;&amp; cd truffle-contract-test$ npm init 接下来安装truffle-contract：$ npm install web3 --save$ npm install truffle-contract --save 注：安装truffle-contract并不要求先安装web3，这里安装web3是因为后面会用到。 初始化合约对象与web3.js类似，要使用truffle-contract，需要先初始化合约对象，然后连接到一个以太坊节点。在truffle-contract-test目录下新建index.js文件，在其中输入以下代码：var Web3 = require("web3");var contract = require("truffle-contract");// 合约ABIvar contract_abi = [&#123; "constant": false, "inputs": [&#123; "name": "receiver", "type": "address" &#125;, &#123; "name": "amount", "type": "uint256" &#125;], "name": "sendCoin", "outputs": [&#123; "name": "sufficient", "type": "bool" &#125;], "payable": false, "type": "function" &#125;, &#123; "constant": false, "inputs": [&#123; "name": "addr", "type": "address" &#125;], "name": "getBalance", "outputs": [&#123; "name": "", "type": "uint256" &#125;], "payable": false, "type": "function" &#125;, &#123; "inputs": [], "payable": false, "type": "constructor" &#125;, &#123; "anonymous": false, "inputs": [&#123; "indexed": true, "name": "_from", "type": "address" &#125;, &#123; "indexed": true, "name": "_to", "type": "address" &#125;, &#123; "indexed": false, "name": "_value", "type": "uint256" &#125;], "name": "Transfer", "type": "event" &#125;];// 通过ABI初始化合约对象var MetaCoin = contract(&#123; abi: contract_abi // 如果要部署合约，还要指定合约代码： // unlinked_binary: ...&#125;);// 连接到以太坊节点var provider = new Web3.providers.HttpProvider("http://localhost:8545");MetaCoin.setProvider(provider); 接下来，可以使用MetaCoin的以下三个函数： at(contract_address)：通过指定的合约地址获取MetaCoin合约实例 deployed()：通过默认的合约地址获取MetaCoin合约实例 new()：部署新的合约，并且获取新部署的合约实例 调用合约函数可以像下面这样调用getBalance函数：// 改成你自己的账户地址var account_one = "0x68b73956d704007514e9257813bdc58cdf3c969a";// 合约地址，改成你自己的合约地址var contract_address = "0xb2cdd356e58280906ce53e1665697b50f88aac56";MetaCoin.at(contract_address).then(function(instance)&#123; return instance.getBalance.call(account_one);&#125;).then(function(balance)&#123; console.log(balance.toNumber());&#125;).catch(function(err)&#123; console.log(err);&#125;); 首先通过MetaCoin.at()获取合约实例，在.then链式调用中，回调函数会在参数中获取到合约实例instance，接下来就可以在回调函数中使用合约实例来调用getBalance函数，再继续通过.then链式调用，通过回调函数获得getBalance的返回值balance。 再来看看调用sendCoin函数的情况：// 改成你自己的账户地址var account_one = "0x68b73956d704007514e9257813bdc58cdf3c969a";var account_two = "0x9c3c1a2f5ef913fac44f0348a78f68d835f3f26e";// 合约地址，改成你自己的合约地址var contract_address = "0xb2cdd356e58280906ce53e1665697b50f88aac56";MetaCoin.at(contract_address).then(function(instance)&#123; // 调用sendCoin会向区块链发送一笔交易 return instance.sendCoin(account_two, 100, &#123;from:account_one&#125;);&#125;).then(function(result)&#123; // 这个回调函数在交易生效之后才会被执行 // result对象包含以下三个字段： // result.tx =&gt; 交易hash，是一个string // result.receipt =&gt; 交易执行结果，是一个对象 // result.logs =&gt; 交易产生的事件集合，是一个对象数组 console.log(result);&#125;).catch(function(err)&#123; console.log(err);&#125;); 这里，调用sendCoin会向区块链发送一笔交易，在交易生效之后，才会执行回调函数，回调函数的参数中包含了交易hash、交易执行结果以及交易产生的事件。 捕获事件可以通过result.logs获取交易触发的事件：// 改成你自己的账户地址var account_one = "0x68b73956d704007514e9257813bdc58cdf3c969a";var account_two = "0x9c3c1a2f5ef913fac44f0348a78f68d835f3f26e";// 合约地址，改成你自己的合约地址var contract_address = "0xb2cdd356e58280906ce53e1665697b50f88aac56";MetaCoin.at(contract_address).then(function(instance)&#123; // 调用sendCoin会向区块链发送一笔交易 return instance.sendCoin(account_two, 100, &#123;from:account_one&#125;);&#125;).then(function(result)&#123; // 这个回调函数在交易生效之后才会被执行 // result.logs是一个数组，数组的每个元素是一个事件对象 // 通过查询result.logs可以获得感兴趣的事件 for (var i = 0; i &lt; result.logs.length; i++) &#123; var log = result.logs[i]; if (log.event == "Transfer") &#123; console.log("from:", log.args._from); console.log("to:", log.args._to); console.log("amount:", log.args._value.toNumber()); break; &#125; &#125;&#125;).catch(function(err)&#123; console.log(err);&#125;);// 输出：from: 0x68b73956d704007514e9257813bdc58cdf3c969ato: 0x9c3c1a2f5ef913fac44f0348a78f68d835f3f26eamount: 100 sendCoin执行完后会触发一个Transfer事件，在回调函数中，通过查询result.logs可以获取到这个事件，进而可以得到事件的参数值。 一个完整的例子下面是一个完整的例子：var Web3 = require("web3");var contract = require("truffle-contract");// 合约ABIvar contract_abi = [&#123; "constant": false, "inputs": [&#123; "name": "receiver", "type": "address" &#125;, &#123; "name": "amount", "type": "uint256" &#125;], "name": "sendCoin", "outputs": [&#123; "name": "sufficient", "type": "bool" &#125;], "payable": false, "type": "function" &#125;, &#123; "constant": false, "inputs": [&#123; "name": "addr", "type": "address" &#125;], "name": "getBalance", "outputs": [&#123; "name": "", "type": "uint256" &#125;], "payable": false, "type": "function" &#125;, &#123; "inputs": [], "payable": false, "type": "constructor" &#125;, &#123; "anonymous": false, "inputs": [&#123; "indexed": true, "name": "_from", "type": "address" &#125;, &#123; "indexed": true, "name": "_to", "type": "address" &#125;, &#123; "indexed": false, "name": "_value", "type": "uint256" &#125;], "name": "Transfer", "type": "event" &#125;];// 通过ABI初始化合约对象var MetaCoin = contract(&#123; abi: contract_abi // 如果要部署合约，还要指定合约代码： // unlinked_binary: ...&#125;);// 连接到以太坊节点var provider = new Web3.providers.HttpProvider("http://localhost:8545");MetaCoin.setProvider(provider);// 改成你自己的账户地址var account_one = "0x68b73956d704007514e9257813bdc58cdf3c969a";var account_two = "0x9c3c1a2f5ef913fac44f0348a78f68d835f3f26e";// 合约地址，改成你自己的合约地址var contract_address = "0xb2cdd356e58280906ce53e1665697b50f88aac56";var coin;MetaCoin.at(contract_address).then(function(instance)&#123; coin = instance; // 首先查看账户二的余额 return coin.getBalance.call(account_two);&#125;).then(function(balance_of_account_two)&#123; console.log("Balance of account two is", balance_of_account_two.toNumber()); // 从账户一向账户二转100个币 return coin.sendCoin(account_two, 100, &#123;from:account_one&#125;);&#125;).then(function(result)&#123; console.log("Sent 100 coin from account one to account two."); // 再次查看账户二的余额 return coin.getBalance.call(account_two);&#125;).then(function(balance_of_account_two)&#123; console.log("Balance of account two is", balance_of_account_two.toNumber());&#125;).catch(function(err)&#123; console.log("Error:", err.message);&#125;); // 输出Balance of account two is 3400Sent 100 coin from account one to account two.Balance of account two is 3500]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以太坊开发实战：通过web3.js与智能合约交互]]></title>
      <url>%2Fposts%2F9cc80f82%2F</url>
      <content type="text"><![CDATA[web3.js是以太坊提供的一个Javascript库，它封装了以太坊的JSON RPC API，提供了一系列与区块链交互的Javascript对象和函数，包括查看网络状态，查看本地账户、查看交易和区块、发送交易、编译/部署智能合约、调用智能合约等，其中最重要的就是与智能合约交互的API。 下面就介绍如何使用web3.js提供的接口调用智能合约。 系统和软件 Ubuntu 16.04 64位 nodejs 6.10.0 npm 3.10.10 示例合约本文以下面的MetaCoin合约为例，说明在应用中使用web3.js操作智能合约的方法。// 本文中用到的MetaCoin合约pragma solidity ^0.4.2;contract MetaCoin &#123; mapping (address =&gt; uint) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function MetaCoin() &#123; balances[tx.origin] = 10000; &#125; function sendCoin(address receiver, uint amount) returns(bool sufficient) &#123; if (balances[msg.sender] &lt; amount) return false; balances[msg.sender] -= amount; balances[receiver] += amount; Transfer(msg.sender, receiver, amount); return true; &#125; function getBalance(address addr) returns(uint) &#123; return balances[addr]; &#125;&#125; 这个合约有三个函数： MetaCoin：构造函数，在合约被部署到区块链时执行 getBalance：返回某账户的余额，它只读数据，不会修改数据 sendCoin：向另一个账户发送指定数量的MetaCoin，它会改变状态变量balances 启动一个以太坊节点，将上面的合约部署到区块链中，并记录下合约的地址，可以通过truffle部署，具体参考这篇文章。接下来就可以按照下面的步骤在项目中通过web3.js来使用这个合约。 添加web3到项目中首先新建一个Nodejs项目并初始化：$ mkdir web3test &amp;&amp; cd web3test$ npm init 会提示输入项目信息，全部默认即可。接下来下载web3.js到项目中：$ npm install web3 --save 以上命令会将web3.js下载到web3test/node_modules目录下，其中--save参数会web3.js添加到package.json配置文件中。 创建web3对象要使用web3.js与区块链交互，需要先创建web3对象，然后连接到以太坊节点。在web3test目录下新建index.js文件，在其中输入以下代码：var Web3 = require("web3");// 创建web3对象var web3 = new Web3();// 连接到以太坊节点web3.setProvider(new Web3.providers.HttpProvider("http://localhost:8545")); 获取已部署的合约实例要使用智能合约，必须先从区块链中获取到合约实例，获取合约实例需要合约的ABI和合约的地址：// 合约ABIvar abi = [&#123;"constant":false,"inputs":[&#123;"name":"receiver","type":"address"&#125;,&#123;"name":"amount","type":"uint256"&#125;],"name":"sendCoin","outputs":[&#123;"name":"sufficient","type":"bool"&#125;],"payable":false,"type":"function"&#125;,&#123;"constant":false,"inputs":[&#123;"name":"addr","type":"address"&#125;],"name":"getBalance","outputs":[&#123;"name":"","type":"uint256"&#125;],"payable":false,"type":"function"&#125;,&#123;"inputs":[],"payable":false,"type":"constructor"&#125;,&#123;"anonymous":false,"inputs":[&#123;"indexed":true,"name":"_from","type":"address"&#125;,&#123;"indexed":true,"name":"_to","type":"address"&#125;,&#123;"indexed":false,"name":"_value","type":"uint256"&#125;],"name":"Transfer","type":"event"&#125;];// 合约地址var address = "0xb2cdd356e58280906ce53e1665697b50f88aac56";// 通过ABI和地址获取已部署的合约对象var metacoin = web3.eth.contract(abi).at(address); metacoin就是获取到的合约对象实例，此时metacoin对象中就包含了与合约函数同名的Javascript函数，之后就可以通过metacoin对象来调用合约中的函数了。 调用合约函数MetaCoin合约中有两个函数：getBalance和sendCoin，可以通过metacoin对象直接调用这两个函数。 首先来看getBalance，由于getBalance函数只是从区块链中读数据，而不修改数据，因此我们通过在getBalance后面加上.call()的方式调用：var account_one = web3.eth.accounts[0];var account_one_balance = metacoin.getBalance.call(account_one);console.log("account one balance: ", account_one_balance.toNumber()); 这里： 在getBalance后加上.call()来显式指明用call的方式调用 通过call的方式调用可以得到getBalance函数的返回值 通过call的方式调用的函数只在节点本地虚拟机中执行，不会产生交易，不会花费费用，不会修改数据 下面来看sendCoin函数，由于sendCoin要修改合约内部的数据，所以要使sendCoin生效，必须要向区块链发送交易，可以在sendCoin后面加上.sendTransaction()来指明这是一笔交易：var account_one = web3.eth.accounts[0];var account_two = web3.eth.accounts[1];// 提交交易到区块链，会立即返回交易hash，但是交易要等到被矿工收录到区块中后才生效var txhash = metacoin.sendCoin.sendTransaction(account_two, 100, &#123;from:account_one&#125;);console.log(txhash); 这里： 在sendCoin函数后加上.sendTransaction()指明要向区块链发送交易 合约代码中sendCoin函数只有两个参数，而在web3中通过.sendTransaction()调用合约函数的时候需要增加最后一个参数，它是一个javascript对象，里面可以指定from/value/gas等属性，上面的例子用from来指定交易的发送者 上面的调用语句执行后，会向区块链提交一笔交易，这笔交易的发送者是account_one，接收者是metacoin的地址，交易的作用是以account_two和100作为参数执行合约的sendCoin函数 函数会立即返回交易的hash，表明交易已经提交到区块链，但是并不知道交易何时处理完成，交易要等到被旷工收录到区块中后才会生效 监听合约事件当通过.sendTransaction()调用合约的时候，交易会被提交到区块链进行处理，这个处理需要一定的时间，如果需要等交易完成之后再执行其他操作，就必须要知道交易何时完成，那么如何知道交易何时完成呢？可以通过监听合约事件来实现。 在合约中可以定义事件，事件可以带有参数，在合约函数内部完成某些操作时，可以触发事件，向外界传达一些信息。例如，在MetaCoin合约中定义了一个事件叫做Transfer，表示一个转账的事件，它带有三个参数：交易的发送者、接受者、转账数量。在sendCoin函数中，转账成功后就会触发Transfer事件，将对应的参数传给该事件，这样外部监听到事件后，可以取出事件的参数来获得交易发送者、接收者、数量。同时事件中还带有其他信息，比如交易hash等。 在web3中使用事件，要首先获取事件对象，然后监听事件，如果事件发生，就会在回调函数中获取到事件信息：// 获取事件对象var myEvent = metacoin.Transfer();// 监听事件，监听到事件后会执行回调函数myEvent.watch(function(err, result) &#123; if (!err) &#123; console.log(result); &#125; else &#123; console.log(err); &#125; myEvent.stopWatching();&#125;);// 输出：&#123; address: '0xb2cdd356e58280906ce53e1665697b50f88aac56', blockNumber: 651, transactionIndex: 0, transactionHash: '0xcc71bc2824cc84d1ee831c46189e3a80cf0af05697ba0370693aa97390c8067b', blockHash: '0x1d53f04206f3926d0f311b1230a9dd0b0c5aadac35b169a6a609e384ab130c6f', logIndex: 0, removed: false, event: 'Transfer', args: &#123; _from: '0x68b73956d704007514e9257813bdc58cdf3c969a', _to: '0x9c3c1a2f5ef913fac44f0348a78f68d835f3f26e', _value: &#123; [String: '100'] s: 1, e: 2, c: [Object] &#125; &#125; &#125; 从输出可以看出，获取到的事件信息包括事件的参数、事件名、区块号、交易hash等。 通过检测事件中的transactionHash与调用合约函数返回的交易hash是否一致，可以判定某一笔交易是否已完成：var account_one = web3.eth.accounts[0];var account_two = web3.eth.accounts[1];var account_one_balance = metacoin.getBalance.call(account_one);console.log("account one balance:", account_one_balance.toNumber());var txhash = metacoin.sendCoin.sendTransaction(account_two, 100, &#123; from: account_one &#125;);var myEvent = metacoin.Transfer();myEvent.watch(function (err, result) &#123; if (!err) &#123; if (result.transactionHash == txhash) &#123; var account_one_balance = metacoin.getBalance.call(account_one); console.log("account one balance after sendCoin:", account_one_balance.toNumber()); &#125; &#125; else &#123; console.log(err); &#125; myEvent.stopWatching();&#125;);// 输出：account one balance: 7000account one balance after sendCoin: 6900 watch中的回调函数如果被执行，说明事件已被触发，也就是说某笔交易已经处理完，检查交易hash是否一致，可以判定产生这个事件的交易是否是自己发送的交易，如果是，就可以进行其他操作，比如查询最新的余额。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以太坊开发实战：Truffle开发环境配置及使用]]></title>
      <url>%2Fposts%2F6dfb7cf8%2F</url>
      <content type="text"><![CDATA[Truffle是一个以太坊智能合约开发框架，利用它可以方便地生成项目模板、编译合约、部署合约到区块链、测试合约等等。本篇文章介绍Truffle的安装过程以及基本使用。 Truffle安装系统环境：Ubuntu16.04 64位 一、安装 NodejsTruffle是一个nodejs模块，因此要先安装nodejs。进入nodejs网站，选择Linux Binaries 64bit下载最新版本的nodejs压缩包，这里以 node-v6.10.0-linux-x64.tar.gz 为例。 将下载的压缩包解压到某个目录下，比如 ~/tools 下：$ tar -C ~/tools -xzf node-v6.10.0-linux-x64.tar.gz 在系统目录下创建到node及npm可执行文件的软链接：$ sudo ln -s ~/tools/node-v6.10.0-linux-x64/bin/node /usr/local/bin/node$ sudo ln -s ~/tools/node-v6.10.0-linux-x64/bin/npm /usr/local/bin/npm 执行 node -v 以及 npm -v ，如果输出nodejs和npm的版本号，说明安装成功了。 二、配置npm源（可选）npm=node package manager，是nodejs的包管理器，nodejs模块都是通过npm来在线安装，很多安装包来自国外，由于网络管制原因，会导致一些包下载很慢甚至安装失败，因此建议把npm的源设置为国内源，用以下命令可以把npm源设置为淘宝镜像源：$ npm config set registry http://registry.npm.taobao.org 三、安装 git为保证truffle的正常安装，执行以下命令安装git：$ sudo apt-get install git 四、安装truffle通过npm安装，安装最新版：$ sudo npm install -g truffle 或安装指定版本：$ sudo npm install -g truffle@~2.1.1 其中@~2.1.1表示安装2.1.1&lt;=version&lt;2.2.0的最新版。 安装完成后在终端输入truffle，发现找不到命令，原因是truffle被安装到了~/tools/node-v6.10.0-linux-x64/bin中，而不是系统目录。为了让终端能识别truffle命令，需要创建一个软链接：$ sudo ln -s ~/tools/node-v6.10.0-linux-x64/bin/truffle /usr/local/bin/truffle 或者将~/tools/node-v6.10.0-linux-x64/bin加入到PATH环境变量中，在~/.bashrc文件最后加入一行：export PATH=$PATH:$HOME/tools/node-v6.10.0-linux-x64/bin 之后再输入truffle，就会显示truffle版本和用法，本例安装的是2.1.2版。 Truffle使用一、创建项目新建一个目录并进入该目录，然后创建项目：$ mkdir myContract &amp;&amp; cd myContract$ truffle init 执行truffle init后，会在当前目录生成一个项目模板，生成的项目目录结构如下：myContract├── app│ ├── images│ ├── index.html│ ├── javascripts│ │ └── app.js│ └── stylesheets│ └── app.css├── contracts│ ├── ConvertLib.sol│ ├── MetaCoin.sol│ └── Migrations.sol├── migrations│ ├── 1_initial_migration.js│ └── 2_deploy_contracts.js├── test│ └── metacoin.js└── truffle.js 其中app是生成的示例web应用代码，contracts下面存放合约代码，migrations里面是部署合约的脚本，test下面是测试脚本，truffle.js是项目的配置文件。 注：这是truffle 2.1.2生成的项目模板，目前truffle最新版3.1.2生成的项目模板中不再包含app目录。 二、编写合约编写合约代码，并把代码文件保存在contracts目录下，默认已经生成了一个示例合约MetaCoin.sol和ConvertLib.sol，如果不需要可以将它们删除，本例就使用默认的示例合约文件。 三、编译合约在终端中输入：$ truffle compile 如果出现类似如下输出，则编译成功：Compiling ConvertLib.sol...Compiling MetaCoin.sol...Compiling Migrations.sol...Writing artifacts to ./build/contracts 四、部署合约首先启动一个私有链节点，在终端中输入下面命令，进入geth控制台：$ geth --datadir chain0/data --networkid 1108 --rpc console 然后修改truffle.js文件，将其中rpc下面的host值改为节点的IP地址，port的值改为geth启动参数中的–rpcport参数值。// truffle.jsmodule.exports = &#123; build: &#123; "index.html": "index.html", "app.js": [ "javascripts/app.js" ], "app.css": [ "stylesheets/app.css" ], "images/": "images/" &#125;, rpc: &#123; host: "localhost", port: 8545 &#125;&#125;; 还要修改migrations/2_deploy_contracts.js，将deployer.deploy的参数中的合约名改为自己要部署的合约名：// migrations/2_deploy_contracts.jsmodule.exports = function(deployer) &#123; deployer.deploy(ConvertLib); deployer.autolink(); deployer.deploy(MetaCoin);&#125;; 接下来在geth控制台中输入以下命令，解锁账户然后让节点开始挖矿：&gt; personal.unlockAccount(eth.accounts[0])&gt; miner.start(1) 最后部署合约到区块链，在终端中执行：$ truffle migrate --reset 如果出现类似如下输出，则部署成功：... (省略)Running migration: 2_deploy_contracts.js Deploying ConvertLib... ConvertLib: 0x4d7032160ef9b300fb0cc83cad97819f89e6fc38 Linking ConvertLib to MetaCoin Deploying MetaCoin... MetaCoin: 0x3e16298422c552ac794c8a83f4fdae62c6bc2a20Saving successful migration to network...Saving artifacts... 五、测试合约进入truffle控制台调试合约合约部署成功后，在终端执行truffle console，可以进入Javascript控制台对合约进行调试：$ truffle consoletruffle(default)&gt; 在Javascript控制台通过ContractName.deployed()或ContractName.at(contractAddress)获取已部署的合约对象，之后就可以通过该对象调用合约的方法进行调试： 获取已部署的合约对象：truffle(default)&gt; var metacoin = MetaCoin.deployed() 首先查看第一个账户的MetaCoin余额：truffle(default)&gt; metacoin.getBalance.call(web3.eth.accounts[0]) 应该返回10000，因为在MetaCoin的构造函数中将合约创建者的初始值设为了10000。 接下来从第一个账户往第二个账户转30个MetaCoin：truffle(default)&gt; metacoin.sendCoin.sendTransaction(web3.eth.accounts[1],30,&#123;from:web3.eth.accounts[0]&#125;) 上面调用sendCoin会向区块链发送一笔交易，需要节点挖矿使交易生效。 转账成功后再查看两个账户的余额是否发生了变化：truffle(default)&gt; metacoin.getBalance.call(web3.eth.accounts[0])truffle(default)&gt; metacoin.getBalance.call(web3.eth.accounts[1]) 执行完后发现accounts[0]的余额变成了9970，accounts[1]的余额变成了30，说明转账成功了。输入.exit可以退出truffle控制台。 运行单元测试Truffle集成了nodejs测试框架Chai(https://github.com/chaijs/chai)，我们可以使用nodejs内置的断言模块assert对合约进行测试。在test/目录下编写合约的测试脚本，然后通过 truffle test 命令执行脚本：$ truffle test]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以太坊开发实战：私有链搭建操作指南]]></title>
      <url>%2Fposts%2Fe47700bb%2F</url>
      <content type="text"><![CDATA[虽然以太坊是一个公有链系统，但是我们可以通过设置一些参数来运行自己的私有链节点，在自己的私有链上进行开发和测试不需要同步公有链数据，也不需要花钱来买以太币，节省存储空间和成本，而且很灵活很方便。本文介绍使用geth客户端搭建私有链的操作步骤，同时会解释在这个过程中用到的各个命令及选项的含义和作用，最后会介绍geth的Javascript Console中的一些常用功能。 系统和软件 Ubuntu 16.04 64位 geth 1.5.6 =&gt;(安装教程) 搭建私有链一、准备创世区块配置文件以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如genesis.json。&#123; "coinbase" : "0x0000000000000000000000000000000000000000", "difficulty" : "0x400", "extraData" : "0x0", "gasLimit" : "0x2fefd8", "nonce" : "0xdeadbeefdeadbeef", "mixhash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "timestamp" : "0x00", "alloc" : &#123;&#125;&#125; 二、初始化：写入创世区块准备好创世区块配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录用来存放区块链数据，假设新建的数据目录为~/privatechain/data0，genesis.json保存在~/privatechain中，此时目录结构应该是这样的：privatechain├── data0└── genesis.json 接下来进入privatechain中，执行初始化命令：$ cd privatechain$ geth --datadir data0 init genesis.json 上面的命令的主体是geth init，表示初始化区块链，命令可以带有选项和参数，其中--datadir选项后面跟一个目录名，这里为data0，表示指定数据存放目录为data0，genesis.json是init命令的参数。 运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到以下的输出内容，说明初始化成功了。I0322 10:52:44.585282 cmd/geth/chaincmd.go:131] successfully wrote genesis block and/or chain rule set: b240e0678c2a8f87cf350225b528e3d97688aad6d4d84ee84e405c7fc9e37e4e 初始化成功后，会在数据目录data0中生成geth和keystore两个文件夹，此时目录结构如下：privatechain├── data0│ ├── geth│ │ └── chaindata│ │ ├── 000002.log│ │ ├── CURRENT│ │ ├── LOCK│ │ ├── LOG│ │ └── MANIFEST-000003│ └── keystore└── genesis.json 其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 三、启动私有链节点初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：$ geth --datadir data0 --networkid 1108 console 上面命令的主体是geth console，表示启动节点并进入交互式控制台，--datadir选项指定使用data0作为数据目录，--networkid选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id。 运行上面的命令后，就启动了区块链节点并进入了Javascript Console：...Welcome to the Geth JavaScript console!instance: Geth/v1.5.6-stable/linux/go1.7.3 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括： eth：包含一些跟操作区块链相关的方法 net：包含以下查看p2p网络状态的方法 admin：包含一些与管理节点相关的方法 miner：包含启动&amp;停止挖矿的一些方法 personal：主要包含一些管理账户的方法 txpool：包含一些查看交易内存池的方法 web3：包含了以上对象，还包含一些单位换算的方法 探索Javascript Console进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。 接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。 一、创建账户前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：&gt; eth.accounts[] 接下来使用personal对象来创建一个账户：&gt; personal.newAccount()Passphrase: Repeat passphrase: "0xc232e2add308136571bb8f9197ba4ae4e5ba9836" 会提示输入密码和确认密码，输入密码不会有显示，只要输入就可以了，之后就会显示新创建的账户地址。 可以创建多个账户，我们再来创建一个账户：&gt; personal.newAccount()Passphrase: Repeat passphrase: "0x814d39aa21f3eed069f2b21da7b5f857f7343afa" 接下来就可以查看到刚才创建的两个账户了：&gt; eth.accounts["0xc232e2add308136571bb8f9197ba4ae4e5ba9836", "0x814d39aa21f3eed069f2b21da7b5f857f7343afa"] 账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。data0├── geth│ ├── chaindata│ ├── LOCK│ ├── nodekey│ └── nodes├── geth.ipc├── history└── keystore ├── UTC--2017-03-22T09-06-47.766993033Z--c232e2add308136571bb8f9197ba4ae4e5ba9836 └── UTC--2017-03-22T09-09-42.041015656Z--814d39aa21f3eed069f2b21da7b5f857f7343afa 小提示：命令都可以按Tab键自动补全。 二、查看账户余额eth对象提供了查看账户余额的方法：&gt; eth.getBalance(eth.accounts[0])0&gt; eth.getBalance(eth.accounts[1])0 目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。 三、启动&amp;停止挖矿通过miner.start()来启动挖矿：&gt; miner.start(1) 其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。 如果想停止挖矿，在js console中输入miner.stop()：&gt; miner.stop() 注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。 挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：&gt; eth.coinbase"0xc232e2add308136571bb8f9197ba4ae4e5ba9836" 现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可：&gt; miner.setEtherbase(eth.accounts[1])true&gt; eth.coinbase"0x814d39aa21f3eed069f2b21da7b5f857f7343afa" 我们还是以账户0作为coinbase，挖到区块以后，账户0里面应该就有余额了：&gt; eth.getBalance(eth.accounts[0])160000000000000000000 getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币：&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),'ether')160 四、发送交易目前，账户一的余额还是0：&gt; eth.getBalance(eth.accounts[1])0 可以通过发送一笔交易，从账户0转移5个以太币到账户1：&gt; amount = web3.toWei(5,'ether')"5000000000000000000"&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)Error: account is locked at web3.js:3119:20 at web3.js:6023:15 at web3.js:4995:36 at &lt;anonymous&gt;:1:1 这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：&gt; personal.unlockAccount(eth.accounts[0])Unlock account 0xc232e2add308136571bb8f9197ba4ae4e5ba9836Passphrase: true 输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易：&gt; amount = web3.toWei(5,'ether')"5000000000000000000"&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)I0322 19:39:36.300675 internal/ethapi/api.go:1047] Tx(0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825) to: 0x814d39aa21f3eed069f2b21da7b5f857f7343afa"0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825" 此时交易已经提交到区块链，返回了交易的hash，但还未被处理，这可以通过查看txpool来验证：&gt; txpool.status&#123; pending: 1, queued: 0&#125; 其中有一条pending的交易，pending表示已提交但还未被处理的交易。 要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：&gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); 当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了：&gt; txpool.status&#123; pending: 0, queued: 0&#125; 此时，交易已经生效，账户一应该已经收到了5个以太币了：&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),'ether')5 五、查看交易和区块eth对象封装了查看交易和区块信息的方法。 查看当前区块总数：&gt; eth.blockNumber33 通过交易hash查看交易：&gt; eth.getTransaction("0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825")&#123; blockHash: "0xf5d3da50065ce5793c9571a031ad6fe5f1af326a3c4fb7ce16458f4d909c1613", blockNumber: 33, from: "0xc232e2add308136571bb8f9197ba4ae4e5ba9836", gas: 90000, gasPrice: 20000000000, hash: "0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825", input: "0x", nonce: 0, r: "0x433fe5845391b6da3d8aa0d2b53674e09fb6126f0070a600686809b57e4ef77d", s: "0x6b0086fb76c46024f849141074a5bc79c49d5f9a658fd0fedbbe354889c34d8d", to: "0x814d39aa21f3eed069f2b21da7b5f857f7343afa", transactionIndex: 0, v: "0x1b", value: 5000000000000000000&#125; 通过区块号查看区块：&gt; eth.getBlock(33)&#123; difficulty: 132928, extraData: "0xd783010506846765746887676f312e372e33856c696e7578", gasLimit: 3244382, gasUsed: 21000, hash: "0xf5d3da50065ce5793c9571a031ad6fe5f1af326a3c4fb7ce16458f4d909c1613", logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", miner: "0xc232e2add308136571bb8f9197ba4ae4e5ba9836", mixHash: "0x09849dff7c8b8467812fa80d1fa2a27bc61f1cf16d5b2c05a6ce1b77ee18f3f1", nonce: "0x5b3939449dbdbea0", number: 33, parentHash: "0xeca34637642f56f7cfe5b699031c7ddbc43aee00fb10c7f054e0a9719cf226da", receiptsRoot: "0xd5f5b7ee944e57cbff496f7bdda7ceffd5eedffe6d5be5320008190502adc07a", sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", size: 649, stateRoot: "0xc7add6b756980ab9e482766e455597ef1583e747ad62e2924a8e66c6f9170112", timestamp: 1490183209, totalDifficulty: 4358016, transactions: ["0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825"], transactionsRoot: "0x7335a362b2c3925e7ba1b41bf7772aa9645a13d4f9c12edd5892b87887264232", uncles: []&#125; 还有更多的功能请自行探索…。 六、连接到其他节点可以通过admin.addPeer()方法连接到其他节点，两个节点要想联通，必须保证网络是相通的，并且要指定相同的networkid。 假设有两个节点：节点一和节点二，networkid都是1108，通过下面的步骤就可以从节点一连接到节点二。 首先要知道节点二的enode信息，在节点二的js console中执行下面的命令查看enode信息：&gt; admin.nodeInfo.enode"enode://9e86289ea859ca041f235aed87a091d0cd594b377cbe13e1c5f5a08a8a280e62d4019ac54063ed6a1d0e3c3eaedad0b73c40b99a16a176993f0373ffe92be672@[::]:30304" 然后在节点一的js console中执行admin.addPeer()，就可以连接到节点二：&gt; admin.addPeer("enode://9e86289ea859ca041f235aed87a091d0cd594b377cbe13e1c5f5a08a8a280e62d4019ac54063ed6a1d0e3c3eaedad0b73c40b99a16a176993f0373ffe92be672@127.0.0.1:30304") addPeer()的参数就是节点二的enode信息，注意要把enode中的[::]替换成节点二的IP地址。连接成功后，节点二就会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块，向任意一个节点发送交易，另一个节点也会收到该笔交易。 通过admin.peers可以查看连接到的其他节点信息，通过net.peerCount可以查看已连接到的节点数量。 除了上面的方法，也可以在启动节点的时候指定--bootnodes选项连接到其他节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以太坊开发实战：geth客户端安装]]></title>
      <url>%2Fposts%2F4c678d5d%2F</url>
      <content type="text"><![CDATA[geth是以太坊的官方客户端，它是一个命令行工具，提供很多命令和选项，可以运行以太坊节点、创建和管理账户、发送交易、挖矿、部署智能合约等。 下面介绍geth的三种安装方法： 直接下载可执行文件 在线安装 从源码编译安装 方法一 直接下载可执行文件最简单的方法是直接下载可执行文件，以太坊开发团队提供了各个系统的编译好的geth可执行文件，可以去官方下载地址或国内镜像下载适合你系统版本的压缩包，解压缩后直接运行就可以。在命令行中输入 geth help 可查看geth的用法。 注意1：geth是一个命令行工具，需要在命令行中运行geth，windows用户不要直接双击geth.exe。注意2：如果不加任何参数直接运行 geth ，会自动连接到以太坊公网，此时会开始同步区块，在Linux系统中，区块数据默认存储在~/.ethereum中。 方法二 在线安装Ubuntu用户可以选择在线安装的方式，在终端中依次执行以下命令即可：$ sudo add-apt-repository -y ppa:ethereum/ethereum$ sudo apt-get update$ sudo apt-get install ethereum 安装完成后执行 geth help 查看geth的用法。 方法三 从源码编译安装编译安装推荐使用Linux系统，本文以64位的Ubuntu14.04系统为例。geth是用go语言写的，编译geth源码需要go语言和C语言编译器，因此需要先安装go语言，go语言版本推荐用go1.7及以上。 使用make编译首先下载geth源码 go-ethereum，这里以 go-ethereum-1.5.6.tar.gz 为例： 接下来解压缩源码：$ tar -xzf go-ethereum-1.5.6.tar.gz 用make工具进行编译：$ cd go-ethereum-1.5.6$ make geth make会执行build目录下的编译脚本，编译脚本会调用go语言编译器进行编译。等待十几秒，编译就完成了，此时会在 go-ethereum-1.5.6/build/bin 中生成geth可执行文件。 输入 geth help 命令，会显示geth所有的命令和选项：$ cd build/bin$ ./geth help 使用go语言编译工具编译如果熟悉go语言，可以直接使用go语言的编译工具编译。 首先下载go-ethereum项目源码：$ go get -d github.com/ethereum/go-ethereum 上面的命令会下载go-ethereum源码到GOPATH/src/github.com/ethereum/go-ethereum，同时会下载相关的依赖包，在国内网络环境下，如果不翻墙，下载通常会失败，此时可以参考下面的手动下载方法。 下载完成后，通过以下命令编译：$ go install -v github.com/ethereum/go-ethereum/cmd/geth 等待十几秒，编译完成后，会在GOPATH/bin目录下生成geth可执行文件。 注：如果go get命令下载很慢或失败，可以采用手动下载：首先下载 go-ethereum-1.5.6.tar.gz ，然后解压到GOPATH/src/github.com/ethereum/go-ethereum，还要到http://www.golangtc.com/download/package下载golang.org.x.net.tar.gz，并将其解压到GOPATH/src中。解压之后的目录结构应该是这样的：GOPATH/src├── github.com│ └── ethereum│ └── go-ethereum└── golang.org └── x └── net 之后再通过上面的go install命令编译安装即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go语言安装教程]]></title>
      <url>%2Fposts%2F1c3f4ffd%2F</url>
      <content type="text"><![CDATA[Go语言是由Google的三位工程师开发的一种静态类型、编译型、具有垃圾回收功能的编程语言，于2009年正式发布，从2015年开始迅速流行起来。Go的语言特性简单，易学易用，是一种比较轻量级的语言，有C语言基础的人很容易上手，它具有独特的并发机制，非常容易写出高并发的程序，并且标准库中有丰富的网络库、各种编码/解码库、加密算法库等，开发非常方便。著名的Docker容器就是Go语言写的，近一两年流行的区块链技术中的代表者以太坊和HyperLedger也是用Go语言写的。 下面介绍在Linux和Windows系统上安装Go语言的步骤。 首先下载安装包，可以去go语言官网下载，如果没有翻墙，可以去go语言中文网下载对应系统的安装包，目前go语言最新版本是1.8，本文以1.7.3版本为例。 Linux系统安装方法以64位Ubuntu14.04为例： 一、下载安装包 下载安装包 go1.7.3.linux-amd64.tar.gz 二、解压缩到/usr/local $ sudo tar -C /usr/local -xzf go1.7.3.linux-amd64.tar.gz 这会将go语言安装到 /usr/local/go 中 三、添加到环境变量 将/usr/local/go/bin添加到PATH环境变量中，编辑~/.bashrc文件，在文件最后加入下面一行代码：export PATH=$PATH:/usr/local/go/bin 四、设置GOPATH GOPATH用于指定系统中的一个目录，go语言的所有项目都放在这个目录中，比如我想把go语言项目都放在$HOME/work中，那就把GOPATH设置成这个目录：export GOPATH=$HOME/work 将上面一行代码添加到~/.bashrc中即可 最后，别忘了执行以下命令使修改后的~/.bashrc生效：$ source ~/.bashrc 在命令行中执行 go version 命令，如果输出版本信息，则安装成功。 Windows系统安装方法以64位win10为例： 一、下载安装程序 下载安装程序 go1.7.3.windows-amd64.msi 并安装 二、设置GOPATH “我的电脑”-&gt;右键“属性”-&gt;“高级系统设置”-&gt;“环境变量”，在系统变量那选择“新建”，输入变量名GOPATH，变量值D:\mygo，保存即可，其中变量值可以随意指定一个空目录作为go项目的根目录。 在命令行执行 go env 命令 可以查看GOPATH是否正确设置。 查看文档在命令行中执行 godoc -http=:6060 ,会在本机启动go语言文档服务器，不要关闭命令行窗口，在浏览器地址栏输入 http://localhost:6060/ 即可在本地查看go语言的文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fposts%2F4a17b156%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
